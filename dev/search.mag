/*--- 
     Functions that just use involutions to get lower bounds on the sizes of 
     independent (generating) sets in a given group
---*/

// are the generating sets of X and Y conjugate in G? Probably too slow ...
__IS_EQUIVALENT := function (G, X, Y)
  if (#X ne #Y) or (Ngens (X) ne Ngens (Y)) then 
    return false;
  end if;
  r := Ngens (X);
  S := [ s : s in SymmetricGroup (r) ];
  LX := [ X.i : i in [1..Ngens (X)] ];
  LY := [ Y.i : i in [1..Ngens (Y)] ];
  equiv := false;
  j := 0;
  while (not equiv) and (j lt #S) do
    j +:= 1;
    s := S[j];
    equiv := IsConjugate (G, LX, [ LY[i^s] : i in [1..r] ]);
  end while;
return equiv;
end function;

GetDihedralSubgroups := function (G)
     classes := ConjugacyClasses (G);
     reps := [ c[3] : c in classes | Order (c[3]) ne 1 ];
     dihedrals := [ ];
     for r in reps do
          R := sub < G | r >;
          N := Normalizer (G, R);
          clN := ConjugacyClasses (N);
          clN2 := [ c[3] : c in clN | 
                           (Order (c[3]) eq 2) and (c[3]*r*c[3] eq r^-1) and (c[3] ne r) ];
          for t in clN2 do
               // get involution generators
               assert exists(u) { s : s in sub<G|r,t> | Order(s) eq 2 and s*t eq r };
               D := sub < G | t , u >;
               if forall { X : X in dihedrals | not IsConjugate (G, X, D) } then 
                    Append (~dihedrals, D);
               end if;
          end for;
     end for;
return dihedrals;
end function;

__Extend := function (G, SUBS, INVS : REFINE := false)
     NSUBS := [ ];
     for H in SUBS do  
          gens := [ H.i : i in [1..Ngens (H)] ];
          HINVS := [ t : t in INVS | not t in H ];
          if REFINE then 
               CH := Centraliser (G, H);
               HINVS := RefineClass (CH, HINVS);
          end if;
          for t in HINVS do 
               J := sub < G | gens cat [t] >;
               if IsIndependent (J) then
                    if forall { X : X in NSUBS | not IsConjugate (G, X, J) } then
                          Append (~NSUBS, J);
                    end if; 
               end if;
          end for;
     end for;
return NSUBS;
end function;

/*
   The following function is certainly not exhaustive (nor optimized)
   but it tries to find the largest set of independent involution 
   generators for the given group.
*/

IIG := function (G : REFINE := false)
ttt := Cputime ();
     SUBS := GetDihedralSubgroups (G);
     INVS := Involutions (G);
"time to initialize:", Cputime (ttt);
     CONTINUE := true;
     while CONTINUE do
ttt := Cputime ();
          NSUBS := __Extend (G, SUBS, INVS : REFINE := REFINE);
"   time to extend", #SUBS, "subgroups:", Cputime (ttt);
          CONTINUE := (#NSUBS gt 0);
          if CONTINUE then 
               SUBS := NSUBS;
          end if;
     end while;
assert forall { X : X in SUBS | IsIndependent (X) };
return SUBS;
end function;

/*
  Here's a (probably terrible) recursive function to find largest
  independent sets of elements in a given group.

  The input is a group G. The output is a list of subgroups of G 
  whose generators are independent sets in G of largest size.
*/

__LIS_Extend := function (G, H, S)
     LE := [ sub < G | H , S[1] > ];
     for i in [2..#S] do
          Y := sub < G | H , S[i] >;
          //if forall { X : X in LE | not __IS_EQUIVALENT (G, X, Y) } then 
          if forall { X : X in LE | not IsConjugate (G, X, Y) } then  
               Append (~LE, Y);
          end if;
     end for;
return LE;
end function;

LargestIndependentSets := function (G)
     if IsCyclic (G) then
          assert exists (g){ x : x in G | Order (x) eq #G };
          return [ sub < G | g > ], 1;
     end if;
     maxes := [ x`subgroup : x in MaximalSubgroups (G) ];
     L := [ ];
     r := 0;
     for M in maxes do
          LM, rM := $$ (M);
          if rM ge (r-1) then    // the subgroups in LM can possibly extend to subgroups on at least as many gens as those in L
               for H in LM do
                    S := [ g : g in G | IsIndependent (sub < G | H, g >) ];   // this could be really terrible
                    if #S gt 0 then
                         LE := __LIS_Extend (G, H, S);
                         if (rM eq r-1) then   // r remains the same
                              L cat:= LE;
                         else    // here, rM is at least r, so we replace L
                              L := LE;
                              r := rM + 1;
                         end if;
                    end if;
               end for;
          end if;
     end for;
return L, r;
end function;

// gens := [ H.i : i in [1..Ngens (H)] ];
// LIMIT := 10^4;
// i := 0;
// FOUND := false;
// while (not FOUND) and (i lt LIMIT) do
//   i +:= 1;
//   g := Random (M23);
//   J := sub < M23 | gens cat [g] >;
//   if IsIndependent (J) then 
//     FOUND := true;
//   end if;
// end while;


// earlier search code 
MyIGS := function (G)
  n := Ngens (G);
  isit := true;
  for i in [1..n] do 
    if G.i in sub < G | [ G.j : j in Remove([1..n], i) ] > then
      isit := false;
      "i=", i;
    end if;
  end for;
return isit;
end function;

/* -------- my code in progress for IGS search ------- */

isEquivalent := function (X, Y)
     basics := false;
     if Ngens (X) eq Ngens (Y) then 
       m := {* Order (X.j) : j in [1..Ngens (X)] *};
       if m eq {* Order (Y.j) : j in [1..Ngens (Y)] *} then
         if #X eq #Y then 
           basics := true;
         end if;
       end if;
     end if;
     if basics then 
          // try all homomorphisms between compatible tuples
          P := DirectProduct ([ SymmetricGroup (n) : n in Multiplicities (m) ]);
          P := [ g : g in P ];
          genX := [ ]; genY := [ ];
          for ord in Set (m) do
               genX cat:= [ X.j : j in [1..Ngens (X)] | Order (X.j) eq ord ];
               genY cat:= [ Y.j : j in [1..Ngens (Y)] | Order (Y.j) eq ord ];
          end for;
          iso := false;
          i := 0;
          XX := sub < Generic (X) | genX >;
          YY := sub < Generic (Y) | genY >;
          while (i lt #P) and (not iso) do 
               i +:= 1;
               s := P[i];
// NEED CONJUGACY HERE
               iso := IsHomomorphism (XX, YY, [ genY[j^s] : j in [1..#genY] ]);
          end while;
          if iso then 
               return true;
          else 
               return false;
          end if;
     else 
          return false;
     end if;
end function;

// procedure to replace the pointers in F with pointers to 
// orbit reps under the conjugation action of H
procedure orbitReps (~F, H, ELEMENTS) // '~' is optional, but helps readability for potential output
    build := [ ];
    reps := [ ];
    while #build lt #F do
         assert exists (p){ q : q in F | not q in build };
         Append (~reps, p);
         x := ELEMENTS[p];
         Cx := Conjugates (H, x);
         posCx := [ Position (ELEMENTS, y) : y in Cx ];
         build cat:= posCx;
    end while;
    F := reps;
end procedure;

isIndep := function (Y)
return forall { j : j in [1..Ngens (Y)] | 
                #sub<Y|[ Y.k : k in [1..Ngens (Y)] | k ne j ]> lt #Y };
end function;


maxIGS := function (G : Cardinality := 0)

     // list the elements of G once and for all
     // hopefully this is the most time consuming step
tt := Cputime ();
     ELTS := [ g : g in G ];
     N := #ELTS;
"time to list elements of G:", Cputime (tt);

     // set up working list WL
     // terms in WL are pairs [X, E], where
     // X is a subgroup of G with independent generators,
     // E is the list of extendable elements; pointers to ELTS 
tt := Cputime ();
     cl := ConjugacyClasses (G);
     WL := [ ];
     for i in [2..#cl] do 
          x := cl[i][3];
          X := sub < G | x >;
          // get elements not in X
          E := [ p : p in [1..N] | not ELTS[p] in X ];
          // refine this list to cut down the search
          C := Centralizer (G, X);
          orbitReps (~E, C, ELTS);
          Append (~WL, <X, E>);
     end for;
"time to initialize:", Cputime (tt);
 
     // set up the maximum IGS so far
     if exists(T){ S : S in WL | #S[1] eq N } then 
          max_so_far := [ T[1].j : j in [1..Ngens (T[1])] ];
     else 
          max_so_far := [ ];
     end if;

     STOP := false;

     // main loop 
     i := 0;
     while (not STOP) do

          i +:= 1;
          "there are", #WL, "items on the working list at the start of iteration", i;

          // remove redundancies
          old_WL := WL;
          WL := [ old_WL[1]] ;
          for j in [2..#old_WL] do
               new := forall { k : k in [1..#WL] | 
                       not isEquivalent (WL[k][1], old_WL[j][1]) };
               if new then 
                    Append (~WL, old_WL[j]);
               end if;
          end for;
          "after removing redundancies, there are", #WL, "items";
          "--------";

          new_WL := [ ];
    
          for i in [1..#WL] do

               // loop through the pairs in the working list
               X := WL[i][1];
               E := WL[i][2];

               // process this pair; three options:
               // (1) the new generator destroys independence. STOP
               // (2) the new generator gives an IGS for G. STOP
               // (3) the new generator gives an IGS for a proper subgroup. ADD
               for p in E do
                    y := ELTS[p];
                    Y := sub < G | [ X.j : j in [1..Ngens (X)] ] cat [y] >;
                    if isIndep (Y) then
                         if #Y eq N then   // update max_so_far
                              if Ngens (Y) gt #max_so_far then 
                                   max_so_far := [ Y.j : j in [1..Ngens (Y)] ];
                              end if;
                         else
                              EY := [ p : p in [1..N] | not ELTS[p] in Y ];
                              // refine this list to cut down the search
                              CY := Centralizer (G, Y);
                              orbitReps (~EY, CY, ELTS);
                              Append (~new_WL, <Y, EY>);
                         end if;
                    end if;
                end for;

          end for;

          if #new_WL eq 0 then 
               STOP := true;
          else 
               WL := new_WL;
          end if;

     end while;

return max_so_far;
end function;


// small example to test pieces of the code

/*
G := SymmetricGroup (6);

ttt := Cputime ();
S1 := maxIGS (G);
"time for PB:", Cputime (ttt);

ttt := Cputime ();
S2 := generate (G);
"time for DL:", Cputime (ttt);
*/

G := SymmetricGroup (6);
time S := maxIGS (G);


// THIS IS PORTED OVER FROM THE /src DIRECTORY ... NOT SURE IF ITS ANY USE AT ALL

// intrinsic IsMGS (X::SeqEnum, A::Grp) -> BoolElt , RngIntElt
//   { Is X an A-minimal generating set of <X^A>? If not return offending generators. }
//      // put in some guards
//      G := MyNormalClosure (X, A);
//      isit := true;
//      k := 0;
//      while (isit and k lt #X) do
//           k +:= 1;
//           Y := [ X[j] : j in [1..#X] | j ne k ];
//           isit and:= (#MyNormalClosure (Y, A) lt #G);
//      end while;
//      if isit then 
//           return true, 0;
//      else 
//           return false, k;
//      end if;
// end intrinsic;


// __RLMGS_once := function (X, A : LIM := 10)
//      Y := sub < X | [ ] >;
//      count := 0;
//      while (#Y lt #X) and (count lt LIM) do 
//           count +:= 1;
//           x := Random (X);
//           if IsMGS (sub < X | Y , x >, A) then 
//                Y := sub < X | Y , x >;
//           end if;
//      end while;
//      if (#Y eq #X) and (Ngens (Y) gt Ngens (X)) then 
//           return Y;
//      else 
//           return X;
//      end if;
// end function;

// // only an intrinsic for temporary convenience!
// intrinsic RandomLargestMGS (G::Grp, A::Grp : LIMIT := 100) -> SeqEnum
//   { Search at random for a A-minimal generating set of largest size. }
//      if Ngens (G) eq 1 then 
//           return [ G.1 ];
//      else 
//           H := PruneToMGS (G, A);
//           // now see if we can do better by random generation
//           for count in [1..LIMIT] do 
//                H := __RLMGS_once (H);
//           end for;
//           assert #H eq #G;
//           return [ H.i : i in [1..Ngens (H)] ]; 
//      end if;
// end intrinsic;

// intrinsic RandomLargestMGS (G::Grp : LIMIT := 100) -> SeqEnum
//   { Search at random for a minimal generating set of largest size. }
//      A := sub < G | [ ] >;
// return RandomLargestMGS (G, A);
// end intrinsic;



// Find the maximum length of a subgroup chain in a group
// Keep this one on the back-burner for now because Dimitri's recurive function if faster
MyChainLength := function (G)
     // if the lattice is very large, this first step will be a problem
     L := SubgroupLattice (G);
     // the last group listed in the lattice should be G,
     // and the first group should be the identity
     assert (L[#L] eq G) and (L[1] eq sub<G|Identity(G)>);
     depths := [ 0 : i in [1..#L] ];
     rem := {1..#L};
     while #rem gt 0 do
          k := Max (rem);
          Exclude (~rem, k);
          M := MaximalSubgroups (L!k);
          for m in M do 
               mi := Integers ()!m;
               depths[mi] := Max (1 + depths[k], depths[mi]);
          end for;
     end while;
     // the identity subgroup must be at the end of any longest chain
     assert forall { i : i in [2..#L] | depths[1] ge depths[i] };
return depths[1];
end function;
