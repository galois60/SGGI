/* 
  Set up the data type SGGI and establish basic properties.
*/

declare type SGGI;

declare attributes SGGI : AsGrp, IsIrred, SchlafliType, DistGens, Rank, HasIP;

/* 
  Description of attributes:
    IsIrred  . . . . . . . True/False depending on whether the SGGI is irreducible.
    SchlafliType . . . . . The Schlafli type of the SGGI. 
    DistGens . . . . . . . The sequence of distinguished generators of the SGGI.
    Rank . . . . . . . . . The rank of the SGGI = # distinguished generators.
    HasIP  . . . . . . . . True/false depending on whether the SGGI has intersection property.
    AsGrp  . . . . . . . . The Magma group underlying the SGGI.
*/


__IsSGGI := function (S)
  n := #S;
  if exists { i : i in [1..n] | Order (S[i]) ne 2 } then
      return false;
  end if;
  return forall { i : i in [1..n-2] |
          forall { j : j in [i+2..n] | Order (S[i] * S[j]) eq 2 } };   
end function;


__SchlafliType := function (S)
  n := #S;
return [ Order (S[i] * S[i+1]) : i in [1..n-1] ];
end function;


__HasIP := function (S)
  n := #S;
  G := Generic (Parent (S[1]));
  if n eq 1 then 
    return true;     
  elif n eq 2 then
      if (S[1], S[2]) ne Identity (G) then
        return true; 
      else 
        return false;
      end if;  
  // recursive case   
  else 
    L := [ S[i] : i in [1..n-1] ];
    R := [ S[i] : i in [2..n] ];
    LEFT := sub < G | L >;
    RIGHT := sub < G | R >;
    MIDDLE := sub < G | [ S[i] : i in [2..n-1] ] >;
    if (LEFT meet RIGHT) eq MIDDLE then
      return $$ (L) and $$ (R);
    else
      return false;
    end if;  
  end if; 
end function;

// the string condition for chiral polytopes
__HasStringPropertyPlus := function (S)
  return forall { i : i in [1..#S-1] | 
            forall { j : j in [i+1..#S] | 
              Order (&* [ S[k] : k in [i..j] ]) eq 2
                   }
                  };
end function;

__IsCPlusSequence := function (S)
  n := #S;
  if not __HasStringPropertyPlus (S) then
    return false;
  end if;
  G := Generic (Parent (S[1]));
  if n lt 2 then 
    return true;
  else   
    L := [ S[i] : i in [1..n-1] ];
    if $$ (L) then 
      LEFT := sub < G | L >;
      return forall { i : i in [1..n-1] |
        LEFT meet sub<G|[S[j] : j in [i..n]]> eq sub<G|[S[j] : j in [i..n-1]]>
                };
    else
      return false;
    end if;
  end if; 
end function;

     /*----- basic constructors for SGGIs -----*/

__GetSGGI := function (G)
  H := New (SGGI);
  H`DistGens := [ G.i : i in [1..Ngens (G)] ];
  H`Rank := Ngens (G);
  T := __SchlafliType ([ G.i : i in [1..Ngens (G)] ]);
  H`SchlafliType := T;
  H`IsIrred := forall { t : t in T | t gt 2 };
  H`AsGrp := G;
return H;
end function;


intrinsic StringGroupGeneratedByInvolutions (G::GrpPerm) -> SGGI
  {Turn the group G generated by involutions into an SGGI.}
  require __IsSGGI ([ G.i : i in [1..Ngens (G)] ]) : "G must be an SGGI";
return __GetSGGI (G);  
end intrinsic;


intrinsic StringGroupGeneratedByInvolutions (G::GrpMat) -> SGGI
  {Turn the group G generated by involutions into an SGGI.}
  require __IsSGGI ([ G.i : i in [1..Ngens (G)] ]) : "G must be an SGGI";
return __GetSGGI (G);  
end intrinsic;



     /*----- basic access funcions for SGGIs -----*/

intrinsic SchlafliType (H::SGGI) -> SeqEnum
  {Return the Schlafli type of the SGGI.}
return H`SchlafliType;
end intrinsic;


// different from the usual usage of `Generators' in Magma
intrinsic Generators (H::SGGI) -> SeqEnum
  {Return the distinguished generating sequence of the SGGI H.}
return H`DistGens;
end intrinsic;


intrinsic Group (H::SGGI) -> Grp
  {Return the group underlying the SGGI.}
return H`AsGrp;
end intrinsic;


intrinsic Rank (H::SGGI) -> RngIntElt
  {Return the rank of the SGGI.}
return H`Rank;
end intrinsic;


intrinsic Print (H::SGGI)
  {Print SGGI.}
  str := Sprintf( "%o.", Type(H`AsGrp) );
  printf "SGGI with underlying group type " cat str;
end intrinsic;


     /*----- properties of SGGIs -----*/

intrinsic HasIntersectionProperty (H::SGGI) -> BoolElt
  {Test whether SGGI satisfies the intersection property.}
  flag := __HasIP (H`DistGens);
  H`HasIP := flag;
return flag;
end intrinsic;


intrinsic IsStringCGroup (H::SGGI) -> BoolElt
  {Test whether SGGI is a string C-group.}
  if assigned H`HasIP then
    return true;
  else
    return HasIntersectionProperty (H);
  end if;
end intrinsic;


intrinsic IsStringCGroup (G::Grp) -> BoolElt
  {Test whether G is a string C-group on its given generator list.}
  H := StringGroupGeneratedByInvolutions (G);
return IsStringCGroup (H);
end intrinsic;


intrinsic IsCPlusGroup (G::GrpMat) -> BoolElt
  {Test whether G is a C+ group on its given generator list.}
  S := [ G.i : i in [1..Ngens (G)] ];
  if not __IsCPlusSequence (S) then 
    return false; 
  end if;
end intrinsic;


intrinsic IsCPlusGroup (G::GrpPerm) -> BoolElt
  {Test whether G is a C+ group on its given generator list.}
  S := [ G.i : i in [1..Ngens (G)] ];
  if not __IsCPlusSequence (S) then 
    return false; 
  end if;
end intrinsic;



     /*----- comparison functions for SGGIs -----*/

intrinsic 'eq' (H::SGGI, J::SGGI) -> BoolElt
  {Basic equality test for SGGIs.}
  if Rank (H) ne Rank (J) then 
       return false;
  elif Type (H`AsGrp) ne Type (J`AsGrp) then
       return false;
  else
       return Generators (H) eq Generators (J);
  end if;
end intrinsic;


intrinsic IsIsomorphic (H::SGGI, J::SGGI) -> BoolElt, HomGrp
  {Decide whether two SGGIs are isomorphic.}
  if Rank (H) ne Rank (J) then
      return false, _;
  end if;
  if #Group (H) ne #Group (J) then
      return false, _;
  end if;
return IsHomomorphism (Group (H), Group (J), Generators (J));
end intrinsic;


intrinsic IsEquivalent (H::SGGI, J::SGGI) -> BoolElt
  {Decide whether two SGGIs are equivalent up to isomorphism and duality.}
  isit, _ := IsIsomorphic (H, J);
  if isit then 
    return true;
  else
    isit, _ := IsIsomorphic (H, Dual (J));
    if isit then return true; end if;
  end if;
return false;
end intrinsic; 

// is list T a G-conjugate of list S?
__IsConjugate := function (G, S, T)
  if S eq [] then
      return true, Identity (G);
  else
      s := S[1];   t := T[1];
      // test and make sure this is the best way to find g
      flag, g := IsConjugate (G, t, s);
      if flag then
          C := Centralizer (G, s);
          rf, h := $$ (C, [S[i] : i in [2..#S]], [T[i]^g : i in [2..#T]]);
          if rf then
              return true, g * h;
          else
              return false, _;
          end if;
      else
          return false, _;
      end if;
  end if;
end function;


intrinsic IsInnerIsomorphic (H::SGGI, J::SGGI) -> BoolElt, GrpElt
  {Decide whether two SGGIs (have the same parent group and) are inner isomorphic.}
  if Rank (H) ne Rank (J) then
      return false, _;
  end if;
  if exists { h : h in Generators (H) | not h in Group (J) } then
      return false, _;
  end if;
  isit, g := __IsConjugate (Group (J), Generators (J), Generators (H));
  if not isit then return false; end if;
return true, g;
end intrinsic;










