/* 
  Set up the data type SGGI and establish basic properties.
*/

declare type SGGI;

declare attributes SGGI : AsGrp, IsIrred, SchlafliType, DistGens, Rank, HasIP;

/* 
  Description of attributes:
    IsIrred  . . . . . . . True/False depending on whether the SGGI is irreducible.
    SchlafliType . . . . . The Schlafli type of the SGGI. 
    DistGens . . . . . . . The sequence of distinguished generators of the SGGI.
    Rank . . . . . . . . . The rank of the SGGI = # distinguished generators.
    HasIP  . . . . . . . . True/false depending on whether the SGGI has intersection property.
    AsGrp  . . . . . . . . The Magma group underlying the SGGI.
*/


__IsSGGI := function (S)
  n := #S;
  if exists { i : i in [1..n] | Order (S[i]) ne 2 } then
      return false;
  end if;
  string:= forall { i : i in [1..n-2] |
          forall { j : j in [i+2..n] | Order (S[i] * S[j]) eq 2 } };   
  if string then   
      return true;
  else
      return false;
  end if;
end function;


__SchlafliType := function (S)
  n := #S;
return [ Order (S[i] * S[i+1]) : i in [1..n-1] ];
end function;


__HasIP := function (S)
  n := #S;
  G := Generic (Parent (S[1]));
  if n eq 1 then 
    return true;     
  elif n eq 2 then
      if (S[1], S[2]) ne Identity (G) then
        return true; 
      else 
        return false;
      end if;  
  // recursive case   
  else 
    L := [ S[i] : i in [1..n-1] ];
    R := [ S[i] : i in [2..n] ];
    LEFT := sub < G | L >;
    RIGHT := sub < G | R >;
    MIDDLE := sub < G | [ S[i] : i in [2..n-1] ] >;
    if (LEFT meet RIGHT) eq MIDDLE then
      return $$ (L) and $$ (R);
    else
      return false;
    end if;  
  end if; 
end function;


     /*----- basic constructors for SGGIs -----*/

__GetSGGI := function (G)
  H := New (SGGI);
  H`DistGens := [ G.i : i in [1..Ngens (G)] ];
  H`Rank := Ngens (G);
  T := __SchlafliType ([ G.i : i in [1..Ngens (G)] ]);
  H`SchlafliType := T;
  H`IsIrred := forall { t : t in T | t gt 2 };
  H`AsGrp := G;
return H;
end function;


intrinsic StringGroupGeneratedByInvolutions (G::GrpPerm) -> SGGI
  {Turn the group G generated by involutions into an SGGI.}
  require __IsSGGI ([ G.i : i in [1..Ngens (G)] ]) : "G must be an SGGI";
return __GetSGGI (G);  
end intrinsic;


intrinsic StringGroupGeneratedByInvolutions (G::GrpMat) -> SGGI
  {Turn the group G generated by involutions into an SGGI.}
  require __IsSGGI ([ G.i : i in [1..Ngens (G)] ]) : "G must be an SGGI";
return __GetSGGI (G);  
end intrinsic;


intrinsic Dual (H::SGGI) -> SGGI
  {The dual of an SGGI.}
  J := H;
  J`DistGens := Reverse (H`DistGens);
  J`SchlafliType := Reverse (H`SchlafliType);
  J`AsGrp := sub < H`AsGrp | J`DistGens >;
return J;
end intrinsic;


     /*----- basic access funcions for SGGIs -----*/

intrinsic SchlafliType (H::SGGI) -> SeqEnum
  {Return the Schlafli type of the SGGI.}
return H`SchlafliType;
end intrinsic;


// different from the usual usage of `Generators' in Magma
intrinsic Generators (H::SGGI) -> SeqEnum
  {Return the distinguished generating sequence of the SGGI H.}
return H`DistGens;
end intrinsic;


intrinsic Group (H::SGGI) -> Grp
  {Return the group underlying the SGGI.}
return H`AsGrp;
end intrinsic;


intrinsic Rank (H::SGGI) -> RngIntElt
  {Return the rank of the SGGI.}
return H`Rank;
end intrinsic;


intrinsic Print (H::SGGI)
  {Print SGGI.}
  str := Sprintf( "%o.", Type(H`AsGrp) );
  printf "SGGI with underlying group type " cat str;
end intrinsic;


     /*----- properties of SGGIs -----*/

intrinsic HasIntersectionProperty (H::SGGI) -> BoolElt
  {Test whether SGGI satisfies the intersection property.}
  flag := __HasIP (H`DistGens);
  H`HasIP := flag;
return flag;
end intrinsic;


intrinsic IsStringCGroup (H::SGGI) -> BoolElt
  {Test whether SGGI is a string C-group.}
  if assigned H`HasIP then
    return true;
  else
    return HasIntersectionProperty (H);
  end if;
end intrinsic;


intrinsic IsStringCGroup (G::Grp) -> BoolElt
  {Test whether G is a string C-group on its given generator list.}
  H := StringGroupGeneratedByInvolutions (G);
return IsStringCGroup (H);
end intrinsic;


     /*----- comparison functions for SGGIs -----*/

intrinsic 'eq' (H::SGGI, J::SGGI) -> BoolElt
  {Basic equality test for SGGIs.}
  if Rank (H) ne Rank (J) then 
       return false;
  elif Type (H`AsGrp) ne Type (J`AsGrp) then
       return false;
  else
       return Generators (H) eq Generators (J);
  end if;
end intrinsic;


intrinsic IsIsomorphic (H::SGGI, J::SGGI) -> BoolElt, HomGrp
  {Decide whether two SGGIs are isomorphic.}

  if Rank (H) ne Rank (J) then
      return false, _;
  end if;

  if #Group (H) ne #Group (J) then
      return false, _;
  end if;

return IsHomomorphism (Group (H), Group (H), Generators (J));

end intrinsic;


/*
   ***** obsolete attempt at isomorphism testing for SGGIs *****
   ***** may revisit at some point, but direct way better  *****

// is list S a translate of list T under the action of G?
__IsTranslate := function (G, S, T)
  if S eq [] then
      return true, Identity (G);
  else
      s := S[1];   t := T[1];
      // test and make sure this is the best way to find g
      flag := exists (g){ h : h in G | t^h eq s };
      if flag then
          Gs := Stabilizer (G, s);
          rf, h := $$ (Gs, [S[i] : i in [2..#S]], [T[i]^g : i in [2..#T]]);
          if rf then
              return true, g * h;
          else
              return false, _;
          end if;
      else
          return false, _;
      end if;
  end if;
end function;

// compute action of Aut(G) (or conj action of G if AUTO = false) on involutions of G
__ActionOnInvolutions := function (G : AUTO := true)
  DOM := Involutions (G);
  n := #DOM;
  S := SymmetricGroup (n);
  if AUTO then
      A := AutomorphismGroup (G);
      gens := [ S![ Position (DOM, DOM[i] @ (A.j)) : i in [1..n] ] : 
                           j in [1..Ngens (A)] ];
  else
      gens := [ S![ Position (DOM, DOM[i] ^ (G.j)) : i in [1..n] ] : 
                           j in [1..Ngens (G)] ];
  end if;
  // NOTE: can create homomorphism A -> ACT if we require conjugating element
  ACT := sub < S | gens >;
return ACT, DOM;
end function;

intrinsic IsIsomorphic (H::SGGI, J::SGGI : 
                             AUTO := true,   // full autos acting or just inner
                             ACTING_GROUP := false,   
                             DOMAIN := []  
                       ) -> BoolElt
  {Decide whether two SGGIs are isomorphic.}

  S := Generators (H);
  T := Generators (J);
  G := Group (H);

  if DOMAIN eq [] then
      assert Type (ACTING_GROUP) eq BoolElt;
      ACTING_GROUP, DOMAIN := __ActionOnInvolutions (G : AUTO := AUTO);
  end if;

  require Type (ACTING_GROUP) eq GrpPerm : "acting group not a per group";

  S := [ Position (DOMAIN, S[i]) : i in [1..#S] ];
  T := [ Position (DOMAIN, T[i]) : i in [1..#T] ];

  isit, _ := __IsTranslate (ACTING_GROUP, S, T);

return isit;

end intrinsic;
*/








