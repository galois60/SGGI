/* 
  This file contains intrinsics that ascertain properties of SGGIs.
*/

intrinsic IsSGGI (G::SeqEnum) -> BoolElt
  {Test whether G is an SGGI on its given generator list.}
  if exists { i : i in [1..Ngens (G)] | Order (G.i) ne 2 } then
      vprint SGGI, 1 : "not all elements are involutions";
      return false;
  end if;
  flag1:= forall { i : i in [1..Ngens (G)-2] |
               forall { j : j in [i+2..Ngens (G)] | Order (G.i * G.j) eq 2 } };   
  if flag1 then   // G satisfies the string condition
       flag2 := forall { i : i in [1..Ngens (G)-1] | Order (G.i * G.(i+1)) gt 2 };
       if not flag2 then
            vprint SGGI, 1 : "G is directly decomposable";
            return false;
       else
            return true;
       and if;
  else
      vprint SGGI, 1 : "G fails the string condition";
  end if;
end intrinsic;

intrinsic IsSGGI (L::SeqEnum) -> BoolElt
  {Test whether the group generated by L is an SGGI on these generators.}
  require forall { i : i in [1..#L] | ISA (Type (L[i]), GrpElt) } : 
     "input list L is not a list of group elements";
  G0 := Generic (Parent (L[1]));
  G := sub < G0 | L >;
return IsSGGI (G);
end intrinsic;

intrinsic IsSGGIModSubgroup (G::Grp, N::Grp) -> BoolElt
  {Test whether G/N is an SGGI.}
   require IsNormal (G, N) : "N is not a normal subgroup of G.";
   if exists { i : i in [1..Ngens (G)] | G.i in N or not (G.i^2 in N) } then
       vprint SGGI, 1 : "generators of G/N are not involutions";
       return false;
   end if;
   flag1:= forall { i : i in [1..Ngens (G)-2] |
               forall { j : j in [i+2..Ngens (G)] | 
                    not (G.i * G.j in N) and ((G.i * G.j)^2 in N)
                   } };   
   if flag1 then   // G/N satisfies the string condition
       flag2 := forall { i : i in [1..Ngens (G)-1] | not (G.i * G.(i+1))^2 in N };
       if not flag2 then
            vprint SGGI, 1 : "G/N is directly decomposable";
            return false;
       else
            return true;
       and if;
  else
      vprint SGGI, 1 : "G/N fails the string condition";
  end if;
end intrinsic;

intrinsic IsSGGIModScalars (G::GrpMat) -> BoolElt
  {Test whether the matrix group G is an SGGI modulo its subgroup of scalar matrices.}
  if exists { i : i in [1..Ngens (G)] | IsScalar (G.i) or not IsScalar (G.i^2) } then
       vprint SGGI, 1 : "generators of G are not involutions mod scalars";
       return false;
   end if;
   flag1:= forall { i : i in [1..Ngens (G)-2] |
               forall { j : j in [i+2..Ngens (G)] | 
                    not IsScalar (G.i * G.j) and IsScalar ((G.i * G.j)^2)
                   } };   
   if flag1 then   // G/Z satisfies the string condition
       flag2 := forall { i : i in [1..Ngens (G)-1] | not IsScalar (G.i * G.(i+1))^2) };
       if not flag2 then
            vprint SGGI, 1 : "G/Z is directly decomposable";
            return false;
       else
            return true;
       and if;
  else
      vprint SGGI, 1 : "G/Z fails the string condition";
  end if;
end intrinsic; 

intrinsic SchlafliSymbol (G::Grp) -> SeqEnum
  {Compute the Schlafli symbol of the SGGI G.}
  require IsSGGI (G) : "G is not an SGGI"; 
return [ Order (G.i * G.(i+1)) : i in [1..Ngens (G)-1] ];
end intrinsic;

intrinsic SchlafliSymbol (L::SeqEnum) -> SeqEnum
  {Compute the Schlafli symbol of the SGGI generated by L.}
  require forall { i : i in [1..#L] | ISA (Type (L[i]), GrpElt) } : 
     "input list L is not a list of group elements";
  G0 := Generic (Parent (L[1]));
  G := sub < G0 | L >;    
return SchlafliSymbol (G);
end intrinsic;

intrinsic HasIntersectionProperty (G::Grp) -> BoolElt
  {Test whether G, with its given generators, satisfies the intersection property.}
  r := Ngens (G);
  // base cases
  if r eq 1 then 
    return true;     
  elif r eq 2 then
      if (G.1, G.2) ne Identity (G) then
        return true; 
      else 
        return false;
      end if;  
  // recursive case   
  else 
    LEFT := sub < G | [ G.i : i in [1..r-1] ] >;
    RIGHT := sub < G | [ G.i : i in [2..r] ] >;
    MIDDLE := sub < G | [ G.i : i in [2..r-1] ] >;
    if (LEFT meet RIGHT) eq MIDDLE then
      return $$ (LEFT) and $$ (RIGHT);
    else
      return false;
    end if;  
  end if; 
end intrinsic;

intrinsic HasIP (G::Grp) -> BoolElt
  {Test whether G, with its given generators, satisfies the intersection property.}  
return HasIntersectionProperty (G);
end intrinsic;

intrinsic HasIntersectionPropertyModSubgroup (G::Grp, N::Grp) -> BoolElt
  {Test whether G/N, with the given generators for G, satisfies the intersection condition.}
  require IsNormal (G, N) : "N is not a normal subgroup of G.";
  r := Ngens (G);
  // base cases
  if r eq 1 then 
    return true; 
  elif r eq 2 then
      if not (G.1, G.2) in N then
        return true; 
      else 
        return false;
      end if;   
  // recursive case
  else 
    LEFT := sub < G | [ G.i : i in [1..r-1] ] >;
    RIGHT := sub < G | [ G.i : i in [2..r] ] >;
    MIDDLE := sub < G | [ G.i : i in [2..r-1] ] >;
    if (LEFT meet RIGHT) subset sub < G | MIDDLE , N > then
      return $$ (LEFT, N) and $$ (RIGHT, N);
    else
      return false;
    end if;       
  end if;
end intrinsic;

intrinsic HasIPModSubgroup (G::Grp, N::Grp) -> BoolElt
  {Test whether G/N, with the given generators for G, satisfies the intersection condition.}
return HasIntersectionPropertyModSubgroup (G, N);
end intrinsic;

intrinsic IsStringCGroup (G::Grp) -> BoolElt
  {Test whether G is a string C-group on its given generator list.}
return IsSGGI (G) and HasIP (G);
end intrinsic;


intrinsic IsStringCGroupModuloSubgroup (G::Grp, N::Grp) -> BoolElt
  {Test whether G/N, with the given generator list for G, is a string C-group.}
return IsSGGIModSubgroup (G, N) and HasIPModSubgroup (G, N);
end intrinsic;

