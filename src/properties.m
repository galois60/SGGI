/* 
  Set up the data type SGGI and establish basic properties.
*/

declare type SGGI;

declare attributes SGGI : AsGrp, IsIrred, SchlafliType, DistGens, Rank, HasIP;

/* 
  Description of attributes:
    IsIrred  . . . . . . . True/False depending on whether the SGGI is irreducible.
    SchlafliType . . . . . The Schlafli type of the SGGI. 
    DistGens . . . . . . . The sequence of distinguished generators of the SGGI.
    Rank . . . . . . . . . The rank of the SGGI = # distinguished generators.
    HasIP  . . . . . . . . True/false depending on whether the SGGI has intersection property.
    AsGrp  . . . . . . . . The Magma group underlying the SGGI.
*/


__IsSGGI := function (S)
  n := #S;
  if exists { i : i in [1..n] | Order (S[i]) ne 2 } then
      return false;
  end if;
  string:= forall { i : i in [1..n-2] |
          forall { j : j in [i+2..n] | Order (S[i] * S[j]) eq 2 } };   
  if string then   
      return true;
  else
      return false;
  end if;
end function;

__SchlafliType := function (S)
  n := #S;
return [ Order (S[i] * S[i+1]) : i in [1..n-1] ];
end function;

__HasIP := function (S)
  n := #S;
  G := Generic (Parent (S[1]));
  if n eq 1 then 
    return true;     
  elif n eq 2 then
      if (S[1], S[2]) ne Identity (G) then
        return true; 
      else 
        return false;
      end if;  
  // recursive case   
  else 
    L := [ S[i] : i in [1..n-1] ];
    R := [ S[i] : i in [2..n] ];
    LEFT := sub < G | L >;
    RIGHT := sub < G | R >;
    MIDDLE := sub < G | [ S[i] : i in [2..n-1] ] >;
    if (LEFT meet RIGHT) eq MIDDLE then
      return $$ (L) and $$ (R);
    else
      return false;
    end if;  
  end if; 
end function;


/* construct an SGGI from a group */
__GetSGGI := function (G)
  H := New (SGGI);
  H`DistGens := [ G.i : i in [1..Ngens (G)] ];
  H`Rank := Ngens (G);
  T := __SchlafliType ([ G.i : i in [1..Ngens (G)] ]);
  H`SchlafliType := T;
  H`IsIrred := forall { t : t in T | t gt 2 };
  H`AsGrp := G;
return H;
end function;

intrinsic StringGroupGeneratedByInvolutions (G::GrpPerm) -> SGGI
  {Turn the group G generated by involutions into an sggi.}
  require __IsSGGI ([ G.i : i in [1..Ngens (G)] ]) : "G must be an SGGI";
return __GetSGGI (G);  
end intrinsic;

intrinsic StringGroupGeneratedByInvolutions (G::GrpMat) -> SGGI
  {Turn the group G generated by involutions into an sggi.}
  require __IsSGGI ([ G.i : i in [1..Ngens (G)] ]) : "G must be an SGGI";
return __GetSGGI (G);  
end intrinsic;



/* basic funcions */

intrinsic SchlafliType (H::SGGI) -> SeqEnum
  {Return the Schlafli type of the sggi H.}
return H`SchlafliType;
end intrinsic;


// different from the usual usage of `Generators' in Magma
intrinsic Generators (H::SGGI) -> SeqEnum
  {Return the distinguished generating sequence of the SGGI H.}
return H`DistGens;
end intrinsic;


intrinsic Rank (H::SGGI) -> RngIntElt
  {Return the rank of sggi H.}
return H`Rank;
end intrinsic;


intrinsic HasIntersectionProperty (H::SGGI) -> BoolElt
  {Test whether sggi H satisfies the intersection property.}
  flag := __HasIP (H`DistGens);
  H`HasIP := flag;
return flag;
end intrinsic;


intrinsic IsStringCGroup (H::SGGI) -> BoolElt
  {Test whether sggi H is a string C-group.}
  if assigned H`HasIP then
    return true;
  else
    return HasIntersectionProperty (H);
  end if;
end intrinsic;


intrinsic IsStringCGroup (G::Grp) -> BoolElt
  {Test whether G is a string C-group on its given generator list.}
  H := StringGroupGeneratedByInvolutions (G);
return IsStringCGroup (H);
end intrinsic;


intrinsic Print (H::SGGI)
  {Print H}
  str := Sprintf( "%o.", Type(H`AsGrp) );
  printf "SGGI with underlying group type " cat str;
end intrinsic;


intrinsic 'eq' (H::SGGI, J::SGGI) -> BoolElt
  {H eq J}
  if Rank (H) ne Rank (J) then 
       return false;
  elif Type (H`AsGrp) ne Type (J`AsGrp) then
       return false;
  else
       return Generators (H) eq Generators (J);
  end if;
end intrinsic;



