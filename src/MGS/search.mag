// code to search for irredundant generating sets of involutions in a (smallish) group

__IsEquivalent := function (G, X, Y : FULL := true)
     if IsConjugate (G, sub < G | X >, sub < G | Y >) then
          if FULL then   // do full test on tuples 
               if {* Order (x1 * x2) : x1 in X , x2 in X *} eq
                  {* Order (y1 * y2) : y1 in Y , y2 in Y *} then
            //    S := SymmetricGroup (#X);
            //    A := sub < G | X >;
            //    B := sub < G | Y >;
            //    if exists { s : s in S | IsHomomorphism (A, B, [ Y[i^s] : i in [1..#X] ]) } then 
            //         return true;
                    return true;
               else 
                    return false;
               end if;
          else
               return true;
          end if;
     else 
          return false;
     end if;
end function;

GetDihedrals := function (G)
     classes := ConjugacyClasses (G);
     reps := [ c[3] : c in classes | Order (c[3]) ne 1 ];
     dihedrals := [ ];
     for r in reps do
          R := sub < G | r >;
          N := Normalizer (G, R);
          clN := ConjugacyClasses (N);
          clN2 := [ c[3] : c in clN | 
                           (Order (c[3]) eq 2) and (c[3]*r*c[3] eq r^-1) and (c[3] ne r) ];
          for t in clN2 do
               // get involution generators
               assert exists(u) { s : s in sub<G|r,t> | Order(s) eq 2 and s*t eq r };
               X := [ t , u ];
               if forall { Y : Y in dihedrals | not __IsEquivalent (G, X, Y) } then
                    Append (~dihedrals, [ t , u ]);
               end if;
          end for;
     end for;
return dihedrals;
end function;

// procedure to replace the pointers in F with pointers to 
// orbit reps under the conjugation action of H
procedure orbitReps (~F, H, ELEMENTS) // '~' is optional, but helps readability for potential output
    build := [ ];
    reps := [ ];
    while #build lt #F do
         assert exists (p){ q : q in F | not q in build };
         Append (~reps, p);
         x := ELEMENTS[p];
         Cx := Conjugates (H, x);
         posCx := [ Position (ELEMENTS, y) : y in Cx ];
         build cat:= posCx;
    end while;
    F := reps;
end procedure;


// can import this: it is in src/MGS/util.mag
MyFactors := function (m)
     facs := Factorization (m);
     mfacs := [ ];
     for pair in facs do
          mfacs cat:= [ pair[1] : i in [1..pair[2]] ];
     end for;
return mfacs;
end function;


// is the number of prime factors in |G| / |<X>| at least k - |X|
__CheckOrder := function (G, X, k)
      H := sub < G | X >;
      ordH := Order (H);
      Verify (H);
      return #MyFactors (Order (G) div Order (H)) ge (k - #X);
end function;


// try to extend the tuple X
__Extend := function (G, X, J, LL, k : REFINE := true)
     extX := [ ];
     POS := [1..#J];
     HX := sub < G | X >;
     if REFINE then 
          CX := Centralizer (G, sub < G | X >);
          orbitReps (~POS, CX, J);
     end if;
     // get rid of the elements that do not give enough room for growth
     POS := [ l : l in POS | __CheckOrder (G, X cat [ J[l] ], k) ];
     for l in POS do
          Y := X cat [ J[l] ];
          // check that Y is irredundant and <Y> is small enough
          if IsMGS (sub < G | Y >) then 
               // see if we have it already
               if forall { Z : Z in LL cat extX | not __IsEquivalent (G, Y, Z) } then
                    Append (~extX, Y);
               end if;
          end if;
     end for;
return extX;
end function;


/* 
   The following function finds all irredundant sets of involutions (ISI) in G.

   One could write down a similar function without the involution 
   constraint, but of course it will be quite a bit slower. 

   With the exception of Alt(n) all known groups G generated by involutions 
   have a largest MGS consisting entirely of involutions.
*/
intrinsic ISI (G::GrpPerm, k::RngIntElt) -> SeqEnum 
  { Return all irredundant sets of involutions in G of size at least k. }
     ordG := Order (G);
     Verify (G);
     L := GetDihedrals (G);
     L := [ X : X in L | __CheckOrder (G, X, k) ];
     if #L eq 0 then 
          return [ ];
     end if;
     I := Involutions (G);
     final_L := [ ];
     done := false;
     while not done do
          if #L[1] ge k then 
               // we want to return all irredundant sets of size at least k
               final_L cat:= L;
          end if;
          "   [IS] trying to extend", #L, "tuples of size", #L[1], "...";
          newL := [ ];
          for X in L do
               // if there is no room to extend X in G do not bother trying 
               J := [ i : i in I | not i in sub < G | X > ];
               newL cat:= __Extend (G, X, J, newL, k);
          end for;
          if #newL eq 0 then 
               done := true;
          else 
               L := newL;
          end if;
     end while;
return final_L;
end intrinsic;

