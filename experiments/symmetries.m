// Quadratic form with 1's on the main diagonal and elements of S on superdiagonal
__QuadraticForm := function (S)
  d := 1 + #S;
  Q := Identity (MatrixAlgebra (Parent (S[1]), d));
  for i in [1..d-1] do
      Q[i][i+1] := S[i];
  end for;
return Q;
end function;

// the subgroup of GL(V) generated by the symmetries determined by points in X 
__SigmaGroup := function (Q, X)
  assert forall { x : x in X | InnerProduct (x * Q, x) ne 0 };
  SX := [ Symmetry (x, Q) : x in X ];
return sub < GL (Nrows (Q), BaseRing (Q)) | SX >;
end function;

// the sigma group defined by a space
SigmaGroup := function (Q, W)
  P := { sub < W | w > : w in W | w ne 0 };
  X := [ x.1 : x in P | InnerProduct (x.1 * Q, x.1) ne 0 ];
return __SigmaGroup (Q, X);
end function;

/* ---- TEST ARGUMENTS IN PROOFS OF LEMMAS ---- */


Prop_3_7 := function (k, n)
  K := GF (2^k);
  if n mod 2 eq 1 then
      d := n+1;
  else 
      d := n+2;
  end if;
  V := VectorSpace (K, d);
  G := GOPlus (d, K);
  Q := ClassicalForms (G)`quadraticForm;
  B := Q + Transpose (Q);
  // find two orth n-subspaces of V that meet in orth (n-1)-subspace
  repeat
      U := sub < V | [ Random (V) : i in [1..n-1] ] >;
      radU := PerpSpace (B, U) meet U;
  until Dimension (U) eq n-1 and Dimension (radU) le 1;
  repeat
      W1 := sub < V | Random (V) , U >;
      radW1 := PerpSpace (B, W1) meet W1;
  until Dimension (W1) eq n and Dimension (radW1) le 1;  
  repeat
      W2 := sub < V | Random (V) , U >;
      radW2 := PerpSpace (B, W2) meet W2;
  until Dimension (W2) eq n and (W1 ne W2) and Dimension (radW2) le 1;
  
  assert W1 meet W2 eq U;
  "W1 has dimension", Dimension (W1);
  "rad(W1) has dimension", Dimension (radW1);
  if Dimension (radW1) eq 1 then
      if InnerProduct (radW1.1 * Q, radW1.1) eq 0 then
      "    and rad(W1) is singular";
      else
      "    and rad(W1) is nonsingular";
      end if;
  end if;
  "   ";
  "W2 has dimension", Dimension (W2);
  "rad(W2) has dimension", Dimension (radW2);
  if Dimension (radW2) eq 1 then
      if InnerProduct (radW2.1 * Q, radW2.1) eq 0 then
      "    and rad(W2) is singular";
      else
      "    and rad(W2) is nonsingular";
      end if;
  end if;
  "   ";
  "U has dimension", Dimension (U);
  "rad(U) has dimension", Dimension (radU);
  if Dimension (radU) eq 1 then
      if InnerProduct (radU.1 * Q, radU.1) eq 0 then
      "    and rad(U) is singular";
      else
      "    and rad(U) is nonsingular";
      end if;
  end if;
  "   ";
  H1 := SigmaGroup (Q, W1);
  H2 := SigmaGroup (Q, W2);
  "   comp facs of H1:";
      CompositionFactors (H1);
  "  ";
  "   comp facs of H2:";
      CompositionFactors (H2);
  "  ";
  SU := SigmaGroup (Q, U);
  J1 := Stabilizer (H1, U);
  J2 := Stabilizer (H2, U);
  "   J1 = J2?", J1 eq J2;
  "basic intersection test:", H1 meet H2 eq SU;
  "(J1 meet J2) = (H1 meet H2)?", (H1 meet H2) eq (J1 meet J2);
  "   ";
  if n mod 2 eq 0 then
  
      assert Dimension (radU) eq 1;
      if InnerProduct (radU.1 * Q, radU.1) eq 0 then
          O2J1 := pCore (J1, 2);
          "    |O2J1| =", Factorization (#O2J1);
          assert #O2J1 eq 2^(k*(n-2));
          O2J2 := pCore (J2, 2);
          "    |O2J2| =", Factorization (#O2J2);
          assert #O2J2 eq 2^(k*(n-2));
          "   |J1| =", #J1;
          "   |J2| =", #J2;
          "   |SU| =", #SU;
      else
      "   comp facs of J1:";
      CompositionFactors (J1);
      "   ";
      "   comp facs of J2:";
      CompositionFactors (J2);
      "   ";
      "   comp facs of SU:";
      CompositionFactors (SU);
      end if;
      
  else
  
      assert Dimension (radW1) eq 1 and Dimension (radW2) eq 1;
      "   comp facs of J1:";
      CompositionFactors (J1);
      "   ";
      "   comp facs of J2:";
      CompositionFactors (J2);
      "   ";
      "   comp facs of SU:";
      CompositionFactors (SU);
      
  end if;
  
return true;
end function;

// check the rank 4 construction for Sp(4,2^k)
Theorem_6_1 := function (k : SANITY := false)

  q := 2^k;
  K := GF (q);
  V := VectorSpace (K, 4);
  spV := Sp (4, K);
  gomiV := GOMinus (4, K);
  if SANITY then assert gomiV subset spV; end if;
  B := ClassicalForms (spV)`bilinearForm;
  Q := ClassicalForms (gomiV)`quadraticForm;
  assert Q + Transpose (Q) eq B;
  
  // find singular line of orthogonal space
  repeat
      repeat
          l := sub < V | Random (V), Random (V) >;
      until Dimension (l) eq 2;
  until IdentifyLineType (Q, l) eq "singular"; 
  assert exists (e){ v : v in l | v ne 0 and InnerProduct (v * Q, v) eq 0 };
  assert exists (b){ v : v in l | InnerProduct (v * Q, v) ne 0 };
  T := PseudoTransvectionGroup (e, b, Q);

  assert exists (rho1){ t : t in T | t ne Identity (T) };
  assert MySupport (rho1) eq l;
  
if SANITY then 
    assert forall { x : x in l | x * rho1 eq x }; 
    lperp := PerpSpace (B, l);
    "l = lperp?", l eq lperp;
end if;
  
  // pick an orthogonal 3-space, U, containing l
  repeat
      repeat 
          u := Random (V);
      until InnerProduct (u * Q, u) ne 0;
      rho0 := Symmetry (u, Q);
  until Order (rho0 * rho1) eq 2*(q+1);
  U := sub < V | l , u >;
  radU := PerpSpace (B, U) meet U;
  assert radU eq PerpSpace (B, sub<U|u>) meet l;
  
  linesU := { sub < U | x , y > : x in U, y in U | Dimension (sub<U|x,y>) eq 2 };
  asingU := [ m : m in linesU | IdentifyLineType (Q, m) eq "asingular" ];
  D01 := sub < gomiV | rho0, rho1 >;
  assert forall { i : i in [1..Ngens (D01)] | radU * (D01.i) eq radU };
  fixed := [ m : m in asingU | forall { i : i in [1..Ngens (D01)] | m * (D01.i) eq m } ];
  assert #fixed eq 1;
  m := fixed[1];
if SANITY then
assert sub<U|u> * rho1 ne sub<U|u>;
assert m eq sub<U|u,u*rho1>;
end if;
  
  sU := Symmetry (radU.1, Q);
  assert sU in D01;
  
  
  assert (Dimension (radU) eq 1) and InnerProduct (radU.1 * Q, radU.1) ne 0;
  
  // do the same but inside u^{perp} to get an orthogonal 3-space, W, containing l.
  Uperp := PerpSpace (B, sub<V|u>);
assert (Uperp meet l) eq radU;
  repeat
      repeat 
          w := Random (Uperp);
      until (InnerProduct (w * Q, w) ne 0) and (not w in U);
      rho2 := Symmetry (w, Q);
  until Order (rho1 * rho2) eq 2*(q+1);
  W := sub < V | l , w >;
  radW := PerpSpace (B, W) meet W;
  assert radU eq PerpSpace (B, sub<U|u>) meet l;
  
  linesW := { sub < W | x , y > : x in W, y in W | Dimension (sub<W|x,y>) eq 2 };
  asingW := [ n : n in linesW | IdentifyLineType (Q, n) eq "asingular" ];
  D12 := sub < gomiV | rho1, rho2 >;
  assert forall { i : i in [1..Ngens (D12)] | radW * (D12.i) eq radW };
  fixed := [ n : n in asingW | forall { i : i in [1..Ngens (D12)] | n * (D12.i) eq n } ];
  assert #fixed eq 1;
  n := fixed[1];
  
  sW := Symmetry (radW.1, Q);
  assert sW in D12;
  
kp := [ (n meet l) , (m meet l) , radU , radW ];

  assert (Dimension (radW) eq 1) and InnerProduct (radW.1 * Q, radW.1) ne 0;
  
  L := sub < GL (4, K) | [rho0, rho1, rho2] >;
  if SANITY then assert L eq gomiV; end if;
  assert IsStringCGroup (L);
  
  T := TransvectionGroup (radU.1, B);
//  assert sU in T;
//  assert exists (rho3){ x : x in T | x ne Identity (T) and x ne sU };
TT := [ x : x in T | (x ne Identity (T)) and (x ne sU) ];
"|TT| =", #TT;
for rho3 in TT do
  line := sub < V | radU.1 , w >;
  D23 := sub < spV | rho2 , rho3 >;
  assert forall { i : i in [1..Ngens (D23)] | line * (D23.i) eq line };
  "new test:", forall { i : i in [1..Ngens (D23)] | radW * (D23.i) eq radW };
  line_perp := PerpSpace (B, line);
  
assert exists (i){ j : j in [1..#kp] | line_perp meet l eq kp[j] };

  // final checks ...
  R := sub < spV | rho1, rho2, rho3 >;
  "comp facs of R:";
  CompositionFactors (R);
  RM := GModule (R);
  "submodule dimensions:", [ Dimension (N) : N in Submodules (RM) ];
  "sU in R?", sU in R;
  "sW in R?", sW in R;
  "R stabilizes W?", forall { i : i in [1..Ngens (R)] | W * (R.i) eq W };
  "R fixes rad(W)?", forall { i : i in [1..Ngens (R)] | radW * (R.i) eq radW };
  "rad(W) is nonsingular?", InnerProduct (radW.1 * Q, radW.1) ne 0;
  "Z(R) =", Centre (R);
  "sW in Z(R)?", sW in Centre (R);
  X := sub < V | w , w * rho1 >;
  "D12 stabilizes <w , w*rho1>?", forall { i : i in [1..Ngens (D12)] |
   X * (D12.i) eq X };
   "R stabilizes <w , w*rho1>?", forall { i : i in [1..Ngens (R)] |
   X * (R.i) eq X };
   RX := Stabiliser (R, X);
   "D12 subset RX?", D12 subset RX;
   "[RX : D12] =", #RX div #D12;
  

  
  H := sub < spV | [ rho0 , rho1 , rho2 , rho3 ] >;
  assert H eq spV;
  "H a string C-group?", IsStringCGroup (H);
  
  COB := Matrix ([u, radU.1, radW.1, w]);
  HH := sub < GL (4, K) | [ COB * H.i * COB^-1 : i in [1..Ngens (H)] ] >;
  [ HH.i : i in [1..Ngens (HH)] ];
"-----------";
end for;
     
return HH;
end function;

__Lemma_3_4 := function (a, b)   // this used to be Lemma_3_8 below
  Q := __QuadraticForm ([a, b]);
"Q =", Q;
  V := VectorSpace (BaseRing (Q), Nrows (Q));
  SigV := SigmaGroup (Q, V);
  U := pCore (SigV, 2);
  L := sub < V | V.1 , V.2 >;
  SigL := SigmaGroup (Q, L);
"|SigV| =", #SigV;
"|SigL| =", #SigL;
  N := Normalizer (SigV, SigL);
  assert N eq SigL;
  X := [ g : g in SigV | not g in SigL ];
  I := [];
  O := [];
  for x in X do
    assert exists (u){w : w in U | SigL^x eq SigL^w};
    assert sub<SigV|SigL,u> eq sub<SigV|SigL,x>;
    C := Centralizer (SigL, u);
    Append (~I, #SigL div #C);
    Append (~O, #sub<SigV|SigL,u>);
  end for;
  "I=",Set (I);
  "O=",Set (O);
return IsMaximal (SigV, SigL);;
end function;

Lemma_3_4 := function (k)
  A := [ a : a in k | a ne 0 ];
  "|A| =", #A;
  for a in A do
    for b in A do
      Q := __QuadraticForm ([a,b]);
      V := QuadraticSpace (Q);
      R := Radical (V);
      if QuadraticNorm (R.1) eq 0 then
         "a =", a, "   b =", b;
         __Lemma_3_4 (a, b);
         "-----------";
      end if;
    end for;
  end for;
return true;
end function;

Lemma_3_8 := function (k)

  K := GF (2^k);
  V := VectorSpace (K, 3);
  
  // first the nonsingular case
  Qn := Matrix (K, 3, 3, [0,1,0,0,0,0,0,0,1]);
  Bn := Qn + Transpose (Qn);
  SigV := SigmaGroup (Qn, V);
  repeat
      repeat
           L := sub < V | [ Random (V) : i in [1,2] ] >;
      until Dimension (L) eq 2 and Rank (RestrictBilinearForm (Bn, L)) eq 2;
  until not IsHyperbolicLine (Qn, L);
  SigL := SigmaGroup (Qn, L);
  assert #SigL eq 2*(2^k + 1);
  "nonsingular case:";
  "   SigL is maximal in SigV?", IsMaximal (SigV, SigL);
"|SigV| =", #SigV;
"|SigL| =", #SigL;
  
  // next, the "anisotropic" singular case
  Qs := Matrix (K, 3, 3, [0 : i in [1..9]]);
  anisotropic := ClassicalForms (GOMinus (2, K))`quadraticForm;
  InsertBlock (~Qs, anisotropic, 1, 1);
  Bs := Qs + Transpose (Qs);
  SigV := SigmaGroup (Qs, V);
  L := sub < V | V.1 , V.2 >;
  SigL := SigmaGroup (Qs, L);
  assert #SigL eq 2*(2^k + 1);
  "singular case:";
  "   SigL is maximal in SigV?", IsMaximal (SigV, SigL);

return true;
end function;


Lemma_4_2 := function (Q)
  d := Nrows (Q);
  V := VectorSpace (BaseRing (Q), d);
  bad := [ ];
  for b in [1..d] do
      for i in [1..d-b+1] do
      "b =", b, "    i =", i;
          X := [ V.j : j in [i..i+(b-1)] ]; 
          A := __SigmaGroup (Q, X);
          W := sub < V | X >;
          assert Basis (W) eq X;
          QW := RestrictQuadraticForm (Q, W);
          BW := QW + Transpose (QW);
          R := Nullspace (BW);
          "   dim(rad(W)) =", Dimension (R);
          if Dimension (R) gt 0 then
          assert Dimension (R) eq 1;
          "   rad(W) =", &+ [ (R.1)[i] * X[i] : i in [1..#X] ];
          "   rad(W) is singular?", InnerProduct ((R.1) * QW, R.1) eq 0;
          end if;
          Y := { sub < W | w > : w in W | InnerProduct (w * Q, w) ne 0 };
          Y := [ z.1 : z in Y ];
          B := [ y : y in Y | not Symmetry (y, Q) in A ];
          if #B gt 0 then
          "   bad points:", B;
              Append (~bad, <b,i,B>);
          end if;
      "---------";
      end for;
  end for;
return #bad eq 0, bad;
end function;


// check the transitivity claim at the end of the lemma
Lemma_4_2a := function (Q)
  d := Nrows (Q);
  V := VectorSpace (BaseRing (Q), d);
  bad := [ ];
  for b in [3..d] do
      for i in [1..d-b+1] do
          Z := sub < V | [ V.j : j in [i..i+(b-1)] ] >;
          W := sub < V | [ V.j : j in [i+1..i+(b-1)] ] >;
          QW := RestrictQuadraticForm (Q, W);
          BW := QW + Transpose (QW);
          R := Nullspace (BW);
          "   radical of W is singular?", InnerProduct ((R.1) * QW, R.1) eq 0;
          N := { sub < Z | z > : z in Z | (InnerProduct (z * Q, z) ne 0)
                                           and not z in sub < V | V.i, V.(i+1) >
                                           and not z in W };
          h := Symmetry (V.i, Q) * Symmetry (V.(i+1), Q);
          for x in N do
              U := sub < V | V.i, V.(i+1), x >;
              L := U meet W;
          end for;  
          "---------";      
      end for;
  end for;
return #bad eq 0, bad;
end function;


